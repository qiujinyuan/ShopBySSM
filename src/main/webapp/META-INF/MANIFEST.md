商城项目

2017.01.10

1. 搭建项目环境
2. 导入前端页面至项目
    index.jsp 为商城首页
    product.jsp 为商品详情页
3. 首页添加搜索功能, 根据
    商品名称(模糊查询), 价格, 类型
4. 将商品分类导航放在 session 中, 然后在 common-header.jsp 中获取
    product.jsp 页面左侧也需要导航数据
5. 最新商品
    最近三个月内的商品

6. 整合 spring 与 mybatis
7. 将 mybatis 改为面向接口

8. 购物车实现
    8.1 加入购物车: 页面弹窗提示加入到购物车中
        先判断当前是否有购物车, 没有购物车则新建一个 cookie, 键名为 cart;
        如果有购物车, 则判断当前商品是否已经存在(根据 id 判断)
            如果不存在, 则新建一个 json 对象, 装当前要添加的商品, 然后将 json 对象添加到 cart 中;
            如果已经存在, 则获取到代表该商品的 json 对象, 然后修改其中的商品数量
        注意: cookie 中存储中文需要设置编码; 而且设置编码到 url 中, 才能在服务器中获取到 session 中的数据
    8.2 结算
        跳转到购物车页面, 在服务器中获取名为 cart 的 cookie 对象, 然后解析 json 对象, 转换为 java 对象
        然后返回到页面上, 通过 jsp 渲染之后直接显式
        注意: 需要先转换编码后, 在创建 java 对象
    8.3 购物车中删除一条购物记录, 整个对象从 cookie 中移除; 
        根据 pid 判断;
        获取 cookie 中 cart 对象, 然后找到 pid 相同的对象, 移除之后重新设置 cookie
        然后刷新页面
9. 购物车改为在 redis 中存储数据: 以便多台设备同步
    9.1 登陆之后, 获取 cart 数据, 然后存储在 redis 数据库中
        redis 中保存用户购物车: 使用 hset() 进行保存, key 为 cart, filed 为用户名, value 为 [{}, {}] 形式的字符串, 表示购物车中的商品    
        未登录用户, 只使用本地 cookie 进行保存信息
        登陆用户: 
            登陆时, 进行判断
                本地 cookie 中有信息, redis 数据库中有信息, 则进行合并: 
                    未设置 cookie 有效期, 关闭浏览器后 cookie 失效; 
                    设置有效期, 下次访问添加商品后再登陆, 则会造成重复(前提是 累加数量; 如果保存数量多的那一方, 则不会出现此问题)
                只有一方有数据, 则替换另一方数据即可
        未登录用户, 登陆时进行判断
    9.2 添加商品到购物车时, 需要同步修改 cookie 和 redis 中的数据
        从购物车删除商品时, 也需要同步进行修改
            跳转到购物车页面或者刷新页面时, 在服务器中更新 redis 中的数据
            修改和删除购物车中的商品, 都需要刷新页面, 所以可以同时更新 redis
            但是还需要判断是否登陆, 未登录则不进行处理; 
            因为在用户登陆时, 已经处理过 cookie 和 redis 中不同步的问题, 所以后面的处理中 cookie 中的数据为最新数据, 以此为准
        退出登陆时, 会删除 cookie 中的购物车数据
        问题: A 和 B 用同一账号登陆, A 将购物车中的商品1 删除, 此时 redis 中该数据被清空, 然后 B 刷新页面, 因为 B 的浏览器的 Cookie 中仍然包括有
        商品 1, 所以更新页面后, 商品1 又被加入到 redis 中, 然后 A 刷新页面(可能需要重新登陆), 商品 1 再次出现
            解决: 以 cookie 为准, cookie 中为最新数据
    
10. 登陆逻辑
    将登陆用户存入 session 中; 退出登录时使 session 失效, 同时清空购物车, 即删除 cookie
    
11. 结算购物车
    通过复选框, 选择需要结算的商品
        传输商品 id, 数量从 redis 中取出, 价格从 mysql 中查询; 构建 ProductInCart 对象, 返回到下单页进行显示
        
        收货地址: 根据该用户查询后返回到页面
    结算时, 不能修改本地 cookie 的购物车信息, 只有提交订单时才修改购物车信息, 并进行同步
        付款方式, 收货地址等信息, 通过表单进行提交
        生成订单信息, 保存到 order_info 表中
        一个订单有多个商品, 对应关系保存在 order_product_info 表中
12. 调用支付宝 api 进行付款
13. 重构部分代码
14. 使用支付异步通知和同步通知
15. 提供订单查询以及未支付订单重新支付功能
16. 聊天室查询功能, 底层数据库由 mongodb 实现, 完成 dao 层模块代码
17. 提供客服登陆页面
    使用 User 类对应客服和用户, 客服 type 为 backUser, 客户 type 为 frontUser
    登陆时, 用户类型存入到当前登陆对象中, 然后保存到 session 中
18. 更新用户列表
    使用 websocket 进行通信;
        1. 打开聊天窗口后则建立连接, 连接至服务器获得所有用户列表
            如果是 用户, 则显示客服列表
            如果是 客服, 则显示用户列表
            关闭聊天窗口后, 再次打开不会建立新连接
        2. 用户下线时, 更新其他用户的用户列表
            如果是 退出登录--> 强制 session 失效, 那么在 onClose() 方法中将报错: session 失效, 导致无法获取到当前用户
            所以应该在退出登录逻辑中, 从 session 中移除当前用户, 而不是直接使 session 失效
            
            已经从 session 移除登陆用户, 再在 onClose() 方法中将获取不到登陆用户, 导致空指针, 报错, 无法正常关闭;
                所以: 下线操作应该在退出登录之前进行
            退出登录一直在请求下线之前执行, 所以会导致从 session 作用域中获取对象时, 获取到 null
                在退出登陆方法中将当前对象从 sessionMap 中移除
                
            更新: 在 onClose() 方法中不再通过 HttpSession 获取 User 对象,
                而是通过 session(value) 在 sessionMap 获取 User 对象, 则不会遇到 session 已经失效或者是 User 对象为 null 的情况
19. 点击用户, 进行聊天
    1. 点击用户列表中的某个用户, 打开对应的聊天窗口
    2. 发送一条消息, 点击发送按钮后, 消息内容显示在聊天窗口中, 同时保存到数据库
    3. 如果消息人在线, 则发送通知, 通知内容包括: 所有未读消息数量和与每个用户的未读消息数量
    4. 消息数量通知使用 jbox 显示在页面右上角
    5. 用户点击用户列表中有未读消息的用户后, 发送更新消息状态的请求, 将与该用户的所有消息状态设置为已读, 同时在设置已读前, 返回与该用户的未读消息列表
    6. 获取到未读消息列表后, 遍历, 构建消息 html 然后添加到聊天窗口中
20. 完善聊天功能
    1. 点击用户通知消息时, 打开对应的聊天窗口, 并显示出未读消息
    2. 点击聊天记录时, 显示所有的聊天信息
    3. 用户登陆成功发出 "登陆成功" 通知, 上线或者是下线时, 通知其他用户
    4. 查看未读消息
        收到消息时, 在用户名旁显示对应用户的未读消息条数
        点击用户列表中的用户时, 更新未读消息条数, 同时关闭对应于该用户的所有通知条
        点击通知条时, 显示聊天消息, 同时更新未读消息条数, 并关闭同名的其他通知条
            实现: 通过获取到 jBox 通知条的 dom 元素, 然后删除, 而不是调用 jBox 对象的 close() 方法